Let's start by installing Express.js.

### Adding new dependency
To add Express.js into the project, we need to add the dependency with the version specified in the **package.json**:

```json
  "dependencies": {
    "express": "^4.18.2"
  }
```  

All dependencies can be installed before running the application using a single command: `npm install`. 

> _For this course, all the dependencies have already been installed when you opened the course, so you don’t need to do anything extra._

<div class="hint" title="package-lock.json">

  The **package-lock.json** file is automatically generated by `npm` when you run `npm install`. 
  It contains an exact, locked-down dependency tree for your project to avoid version inconsistency.
</div>

---

### Creating Express app
Now take a look at the code in **index.js**. 
It does exactly the same as the code from the task [Hello world](course://GettingStartedNode/hello_world), but it looks much better structured.

First, we create an Express application object `app` and then work only with it.

---

### Adding route handlers
HTTP defines a set of request methods to indicate the purpose of the request and what is expected if the request is successful. 
For example, the `GET` method requests a representation of the specified resource. You can read more about HTTP request methods [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods).  

Previously, our handlers did not account for request methods, and that wasn’t entirely correct. 
To add a new `GET` handler, use the `app.get` method, where the first argument is the route and the next is the handler.

```js
app.get('/', (req, res) => {
    res.status(200).type('text/plain').send('Hello, World!');
});
```

In the handler, we set the status code, type, and response text of the response using a pattern called *method chaining*. 
Each method call on the `res` object returns the `res` object itself. This allows multiple methods to be called sequentially on the same object in a single statement.

Also pay special attention to the last handler:
```js  
app.use((req, res) => {
    res.status(404).type('text/plain').send('Page Not Found');
});
```  
- `app.use` is a general-purpose method for defining *middleware*. We’ll discuss it in detail in the next lesson; for now, you can think of it as a handler for all requests.
- Since no path is specified in `app.use`, it applies to all routes globally.
- This particular `use` statement is placed at the end of other handlers' declarations and handles all routes that were not explicitly defined earlier.
- Try moving this declaration to the top, and you’ll see that every route now responds with `Page Not Found`.

---

### Creating httpServer and running it
When creating the HTTP server, the only thing we pass to the `createServer` method is the `app` object, which already contains everything we need.  

Run this application and ensure that it works exactly the same as it did before using Express.

### Reminder
_Click ![](images/run.svg) button in **package.json** to start the application, and after click ![](images/stop.svg) in the in the toolbar at the bottom to stop._

_Remember to rerun your already launched application after making changes to it. You can also do it with ![](images/rerun.svg) button in the toolbar._  

<style>
img {
  display: inline !important;
}
</style>
